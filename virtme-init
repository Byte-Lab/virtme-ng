#!/bin/bash
# virtme-init: virtme's basic init (PID 1) process
# Copyright Â© 2014 Andy Lutomirski
# Licensed under the GPLv2, which is available in the virtme distribution
# as a file called LICENSE with SHA-256 hash:
# 8177f97513213526df2cf6184d8ff986c675afb514d4e68a404010521b880643

export PATH=/bin:/sbin:/usr/bin:/usr/sbin
export TERM=linux

log() {
    if [[ -e /dev/kmsg ]]; then
	echo "<6>virtme-init: $*" >/dev/kmsg
    else
	echo "virtme-init: $*"
    fi
}

mount -t sysfs -o nosuid,noexec,nodev sys /sys/

declare -A mount_tags
for i in /sys/bus/virtio/drivers/9pnet_virtio/virtio*/mount_tag; do
    mount_tags["`cat "$i"`"]=1
done

if [[ -n "${mount_tags[virtme.moddir]}" ]]; then
    mount -t tmpfs none /lib/modules
    kver="`uname -r`"
    mkdir /lib/modules/"$kver"
    mount -n -t 9p -o ro,version=9p2000.L,trans=virtio,access=any virtme.moddir /lib/modules/"$kver"
fi

# Load modules
"$(dirname $0)/virtme-loadmods"

mount -t tmpfs tmpfs /tmp/
mount -t tmpfs tmpfs /run/
[[ -w /var/log ]] || mount -t tmpfs tmpfs /var/log/

# Fix up /etc a little bit
touch /tmp/fstab
mount --bind /tmp/fstab /etc/fstab
rm /tmp/fstab

# Find udevd
if [[ -x /usr/lib/systemd/systemd-udevd ]]; then
    udevd=/usr/lib/systemd/systemd-udevd
else
    udevd=`which udevd`
fi

# Ideally we'll use devtmpfs (but don't rely on /dev/null existing)
if [[ -c /dev/null ]]; then
    mount -t devtmpfs -o mode=0755,nosuid,noexec devtmpfs /dev &>/dev/null
else
    mount -t devtmpfs -o mode=0755,nosuid,noexec devtmpfs /dev
fi

if (( $? != 0 )); then
    # The running kernel doesn't have devtmpfs.  Use regular tmpfs.
    mount -t tmpfs -o mode=0755,nosuid,noexec none /dev

    # Make some basic devices first, and let udev handle the rest
    mknod -m 0666 /dev/null c 1 3
    mknod -m 0660 /dev/kmsg c 1 11
    mknod -m 0600 /dev/console c 5 1
fi

log "basic initialization done"

######## The remainder of this script is a very simple init (PID 1) ########

# Try to get udevd to coldplug everything
"$udevd" --daemon --resolve-names=never
udevadm trigger --action=add  >/dev/null 2>&1
udevadm settle

# Set up filesystems that live in /dev
mkdir -p -m 0755 /dev/shm /dev/pts
mount -t devpts -o gid=tty,mode=620,noexec,nosuid devpts /dev/pts
mount -t tmpfs -o mode=1777,nosuid,nodev tmpfs /dev/shm

# Mount proc
mount -t proc -o nosuid,noexec,nodev proc /proc/

# Bring up networking
ip link set dev lo up

# Create some VTs
deallocvt
openvt -c 2 -- /bin/bash
openvt -c 3 -- /bin/bash
openvt -c 4 -- /bin/bash

# Figure out what the main console is
consdev="`grep ' ... (.C' /proc/consoles  |cut -d' ' -f1`"
if [[ -z "$consdev" ]]; then
    log "can't deduce console device"
    exec bash --login  # At least try to be helpful
fi
if [[ "$consdev" == "tty0" ]]; then
    consdev=tty1  # sigh
fi
if [[ ! -e "/dev/$consdev" ]]; then
    log "/dev/$consdev doesn't exist."
    exec bash --login
fi

echo "virtme-init: console is $consdev"

# Bring up a functioning shell on the console.  This is a bit magical:
# We have no controlling terminal because we're attached to a fake
# console device (probably something like /dev/console), which can't
# be a controlling terminal.  We are also not a member of a session.
# Init apparently can't setsid (whether that's a limitation of the
# setsid binary or the system call, I don't know).
while true; do
    setsid bash 0<>"/dev/$consdev" 1>&0 2>&0
    echo "Shell died.  Will respawn."
    sleep 0.5
done
